**项目代号**: CFS-Local (Computational File System - Local LLM Edition)  
**目标**: 构建双层Agent基础设施——底层为基于FUSE的文件系统接口，上层为Pythonic SDK，统一通过本地LLM（llama-cpp）的"单文件即会话"模型支撑Agent开发。  
**核心范式**: **文件即真相**（File-as-Source-of-Truth），SDK为语法糖，不引入新的状态管理层。

---

## 1. 分层架构

```
┌─────────────────────────────────────────┐
│  Layer 2: Agent SDK (Python)            │
│  - Session (上下文管理器)                │
│  - ChatIterator (流式生成器)             │
│  - Response (结构化输出)                 │
├─────────────────────────────────────────┤  ← Python API 映射为文件操作
│  Layer 1: CFS File System (FUSE)        │
│  - open/write/read/release              │
│  - /cfs/<session_id> 文件即会话上下文    │
└─────────────────────────────────────────┘  ← 对接 llama-cpp (本地GGUF)
```

**关键约束**：SDK不维护独立状态，所有操作最终转化为对CFS文件的`open/write/read`，确保Agent随时可通过标准Unix工具（`cat`, `echo`）与Python SDK互操作。

---

## 2. Layer 1: 文件系统层需求 (CFS Core)

### 2.1 功能需求 (FR-1 ~ FR-5)

**FR-1: 文件生命周期**
- **FR-1.1**: `create()`或`open()`在挂载点创建文件时，初始化空对话历史（内存列表）
- **FR-1.2**: 文件名即为Session ID，扁平化存储（无子目录），支持任意合法文件名
- **FR-1.3**: `unlink()`删除文件时立即释放该Session内存
- **FR-1.4**: **明确限制**：进程结束所有Session丢失（无持久化），无KV Cache管理

**FR-2: 写入与触发**
- **FR-2.1**: `write()`始终为**追加语义**（忽略`offset`参数或强制`O_APPEND`行为）
- **FR-2.2**: 写入内容（UTF-8解码后）前自动添加前缀`User: `，写入后触发后台LLM生成线程
- **FR-2.3**: 同一文件的并发写入由全局锁序列化，生成队列FIFO（单线程调度）
- **FR-2.4**: 触发生成后立即返回写入字节数（非阻塞）

**FR-3: 生成与读取**
- **FR-3.1**: LLM生成格式：追加`Assistant: {content}\n`到文件历史
- **FR-3.2**: `read()`返回完整对话文本（所有历史行用`\n`拼接）
- **FR-3.3**: **阻塞模式**（默认）：若`filename`在`generating`集合中，`read()`睡眠轮询（100ms间隔）直到生成完成
- **FR-3.4**: **非阻塞模式**：若打开时带`O_NONBLOCK`且生成中，立即返回`-EAGAIN`（errno 11）

**FR-4: 提示词构造（无状态重新编码）**
- **FR-4.1**: 每次生成时，将当前文件完整历史按行拼接为Prompt：
  ```
  User: 第一轮输入
  Assistant: 第一轮回复
  User: 第二轮输入
  Assistant: 
  ```
- **FR-4.2**: 调用`llm()`参数：`max_tokens=512`, `temperature=0.7`, `stop=["User:"]`
- **FR-4.3**: 模型输出去除首尾空白后，以`Assistant: `前缀存入历史

**FR-5: 错误与边界**
- **FR-5.1**: 模型加载失败（文件不存在/格式错误）应在挂载前打印错误并退出
- **FR-5.2**: 生成异常（OOM等）捕获后，将`Assistant: [Error: {msg}]`写入历史，标记生成结束

---

## 3. Layer 2: Python SDK层需求 (cfs-client)

### 3.1 设计原则
- **零状态原则**：SDK不缓存对话历史，每次`read()`/`write()`直接操作CFS文件
- **透明映射**：每个SDK方法必须对应明确的文件系统操作（见第4节映射表）
- **语法糖定位**：提供类型安全、流式迭代、上下文管理，但不引入新概念（如独立的数据库或消息队列）

### 3.2 功能需求 (SDK-FR)

**SDK-FR-1: 基础同步接口**
- **SDK-FR-1.1**: `Session(path=None, mount="/cfs")`类：
  - `path`为None时自动生成UUID作为文件名
  - `__enter__`打开（或创建）文件，`__exit__`可选删除或保留（默认保留供Unix工具查看）
- **SDK-FR-1.2**: `session.send(message: str) -> Response`：
  - 阻塞直到生成完成，返回包含`content`（字符串）和`history`（列表）的Pydantic模型
  - 底层：`write(message)` + 轮询`read()`直到文件增长停止
- **SDK-FR-1.3**: `session.read() -> str`：直接读取文件当前完整内容

**SDK-FR-2: 流式接口**
- **SDK-FR-2.1**: `session.stream(message: str) -> Iterator[str]`：
  - 写入消息后，返回生成器逐token产出新增内容
  - 实现方式：记录初始文件大小，循环`read()`检测增长，yield增量文本，直到生成结束标记（或文件大小稳定超过阈值）
  - 支持`break`提前终止（不影响后台生成继续写入文件）

**SDK-FR-3: 异步接口（Phase 2可选，但架构预留）**
- **SDK-FR-3.1**: `AsyncSession`类，提供`await send()`和`async for token in stream()`
- **SDK-FR-3.2**: 利用`aiofiles`操作CFS文件，配合`O_NONBLOCK`标志实现非阻塞IO

**SDK-FR-4: 类型与结构化输出**
- **SDK-FR-4.1**: `Response` Pydantic模型字段：
  - `content: str`（原始Assistant回复）
  - `history: list[str]`（完整历史行列表）
  - `session_id: str`（文件名）
- **SDK-FR-4.2**: `session.send(..., response_format=BaseModel)`（预留接口）：
  - 在Prompt中注入JSON Schema，解析LLM输出为Pydantic对象，失败时自动Retry（最多3次）

**SDK-FR-5: 工具调用预留（架构预留，MVP可不实现，但接口预留）**
- **SDK-FR-5.1**: `Tool`协议定义（`name`, `description`, `callable`）
- **SDK-FR-5.2**: `session.send(..., tools=[...], auto_tool=True)`接口：
  - 检测到Assistant输出包含`[CALL:tool_name(args)]`模式时，执行callable，将结果`write`回Session文件，自动触发下一轮生成

---

## 4. 接口映射规范（SDK ↔ File System）

确保Agent开发者理解SDK底层就是文件：

| SDK操作 | 对应的CFS文件操作 | CFS文件内容变化 |
|---------|------------------|----------------|
| `Session("chat1")` | `open("/cfs/chat1", O_CREAT\|O_RDWR)` | 创建空文件（若不存在） |
| `session.send("hi")` | `write("User: hi\n")` → 触发后台生成 → `read()`等待 | 追加"User: hi\nAssistant: ...\n" |
| `session.read()` | `read()`整个文件 | 读取当前所有行 |
| `for t in session.stream()` | `write()` → 循环`read()`增量（检测文件增长） | 同上，但分块yield |
| `session.close()` | `close()` | 文件保留在`/cfs/`供`cat`查看 |
| `Session.from_file("chat1")` | `open("/cfs/chat1")` | 加载已有历史继续对话 |

---

## 5. 技术栈与实现建议

### 5.1 Layer 1 (FUSE)
- **库**: `fusepy` (Python FUSE binding)
- **LLM后端**: `llama-cpp-python` (本地GGUF)
- **并发**: 单线程FUSE + 后台Thread池（先实现单线程生成队列）
- **存储**: 内存Dict (`{filename: [history_lines]}`)，无磁盘持久化

### 5.2 Layer 2 (SDK)
- **库**: 标准库 + `pydantic`（类型验证）+ `aiofiles`（异步支持，可选）
- **文件检测**: 轮询`os.stat()`文件大小变化（MVP简单方案），或`watchdog`库（inotify）
- **编码**: 强制UTF-8

---

## 6. 验收标准（Acceptance Criteria）

### 6.1 Layer 1 验收（命令行）
```bash
# Test 1: 基础对话
echo "你好" > /tmp/cfs/chat1 && sleep 2
cat /tmp/cfs/chat1 | grep -q "Assistant:" && echo "PASS" || echo "FAIL"

# Test 2: 多轮上下文保持
echo "我叫Alice" >> /tmp/cfs/chat1 && sleep 2
echo "我叫什么？" >> /tmp/cfs/chat1 && sleep 2
cat /tmp/cfs/chat1 | grep -q "Alice" && echo "PASS" || echo "FAIL"

# Test 3: 多文件隔离
echo "你是Python专家" > /tmp/cfs/a && echo "你是Rust专家" > /tmp/cfs/b
# 验证两文件内容独立（手动检查或grep）
```

### 6.2 Layer 2 验收（Python SDK）
```python
from cfs import Session

# Test 1: 基础阻塞调用
with Session() as s:
    r = s.send("你好")
    assert "Assistant:" in r.content
    assert len(r.history) == 2  # User + Assistant

# Test 2: 流式生成
with Session() as s:
    tokens = []
    for token in s.stream("讲个笑话"):
        tokens.append(token)
    assert len(tokens) > 0
    assert s.read().startswith("User:")

# Test 3: SDK与文件系统互操作
s = Session("interop_test")
s.send("测试消息")
import subprocess
output = subprocess.check_output(["cat", "/cfs/interop_test"]).decode()
assert "测试消息" in output
s.close()
```

---

## 7. 给Claude Code的实施指令

### Phase 1: Core Filesystem (cfs.py)
实现第2节的所有FR-1~FR-5，单文件`cfs.py`，要求：
- 代码<150行（含注释）
- 能通过6.1节的命令行测试
- 明确不支持：KV Cache、多模态、MCP工具、持久化、并发调度

### Phase 2: Python SDK (cfs/client.py)
实现第3节的SDK-FR-1~FR-4，单文件`cfs/client.py`，要求：
- 依赖：`pydantic`（必须），`aiofiles`（可选）
- 提供`Session`, `Response`类
- 每个方法注释对应底层文件操作（如`# Maps to: write() + read()`）
- 能通过6.2节的Python测试
- **约束**：SDK不维护内存缓存，所有`history`属性应通过`read()`文件实时获取（或包装文件内容）

### 文档交付
- `README.md`：包含安装步骤、快速开始（Shell方式）、Python SDK示例
- 架构图：简单的分层示意图

**成功定义**：开发者既可以用`echo "hi" > /cfs/chat`快速测试，也可以用Python SDK构建复杂Agent，两者看到的是同一个文件状态。